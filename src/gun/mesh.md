# Ad Hoc Mesh

From the [gitter](https://gitter.im/amark/gun?at=573ca3741794136a7d09e7d9):

GUN的消息传递算法基于全网状网络

但它很好地工作，并且自我减轻了多次重复播送相同的信息。

我将使用非常具体的例子来解释

第一个例子是常见的例子,

Alice连接到服务器。

Bob连接到服务器。

通过服务器，Alice连接到Bob，反之亦然。

默认网络是非常网状的，因为目标是你可以（稍后）智能地只连接到手指来缓解事情。重要的部分是创建一个在任何情况下都可以作为基本案例的紧急系统，然后可以对特定情况进行微调/优化。

所以让我们说爱丽丝保存一些数据

她只连接到1个同伴

所以她将Delta（更改设置）发送给服务器

它在一个消息信封中

其中包含该消息的ID。

服务器收到该消息

并检查该ID是否存在于一个小的固定大小的内存列表中。

该ID不存在。

因此服务器会将它广播给它所连接的所有对等体。（注意：为了安全起见，你可能不需要这个，所以你要添加一个授权过滤器，但我们没有谈论这个，我们正在谈论这个案例）。

这意味着服务器将广播回Alice和Bob。

爱丽丝现在收到她自己的消息

但她不知道这是她自己的

（好吧，她可以，但基本情况是，她不必）

Alice检查消息ID是否在她的小型固定大小的内存列表中。

这是（因为她最初发送消息时已将该ID添加到列表中）

因为它已经存在于她的名单中

她做了2件事

1）将ID打到列表顶部（这是一个固定大小的列表，所以最旧的数据被刷新/移除以节省内存）。将ID跳到最上面非常重要，因为它代表了数据的生动性，以及对于想要减少重播的活泼数据。

2）她不转播。

消息转播现在已经与Alice结束。

为她连接的同龄人

但是，服务器也发送了同样的消息给Bob

鲍勃收到它

检查他的消息ID列表

它不在那里

因此他将它重播给他所连接的同伴。

msg ID会备份到服务器。

服务器检查它的ID列表并且看到它已经存在，并做两件事：

1）将ID打到列表顶部以保持重复数据删除的“活动”状态。

2）通过不重播来重复删除。

现在，网络中的每个对等成功接收到该消息，同时也减轻了重播风暴。该算法工作得非常好，但可以非常容易地针对特定用例和微调进行升级和优化。就像....如果你希望网络流量不是匿名的，你可以在msg信封中标记对等体的ID，这样接收对等体就可以排除它们转播到的对等体列表（这会将回声消除）但是可以暴露身份（对于某些应用程序来说可能没问题）。您还可以将转播次数限制为X个对等节点，例如即使连接到100个对等节点也只有6个对等节点重播。或者只有每个对等节点有6个连接节点。等等。

但是，我们还没有完成！

我们所做的一切都是UDP级别的“遗忘”

但爱丽丝保存了数据

她需要知道保存的数据。

她的ID的回声不是ACK。

呵呵

所以当服务器处理消息时（并且根据时钟漂移，消息可能被推入历史/操作/未来状态并以“不同状态”处理）...

如果服务器成功保存数据，它会发送一条NEW消息

与一个新的ID

但是具有旧ID的回复字段。

这条消息（没有智能/身份优化）会被广播给它所连接的所有同伴

爱丽丝和鲍勃

Alice接收到该消息并且看到它是对其原始保存ID的回复（其存储在单独的列表中）

她现在有一个来自同行的ACK，她的数据得到了复制

从技术上讲，该算法虽然说她也将这个回复消息转播给所有她的同伴（因为重复数据删除/缓解首先发生，而不是最后发生）。如果是这样，她将消息转播给服务器接收到的所有同伴（在本例中只有服务器），并看到消息ID已存在于其已存在的消息ID列表中。因此不会重播。没有哎呀。

然而，让爱丽丝知道这是她自己的消息（来自她的另一张名单），她可以在那里和那里停止转播，这会稍微聪明一点。

同时...... Bob也收到服务器确认

看到它不在他的消息列表中（但将其添加到该消息列表中）并再次重新广播（回到服务器），该消息收到它并看到它在消息列表中并暂停。

现在服务器的ACK已经成功发送给所有的对等体（注意：这是假设网络一直可靠的整个时间!!! ooo-ooo-aaahh - aahhh！Fun CAP定理的东西。不要担心被覆盖太）。

但是现在我们必须处理BOB对Alice通过服务器的中间节点收到的原始保存请求的ACK。

然后BOB保存数据（在现实世界中，浏览器对等体只有在它们是已经订阅的密钥的情况下才将数据保存到本地存储器中，但是仍然可以坚持基本情况）

并在成功保存ACKS之后回复新的MSG ID并回复旧的msg ID。

他连接的唯一对等点是服务器，它在消息列表中没有它，所以它将它重播给每个人（包括回到Bob，它确实拥有了它，然后颠簸和停止），并且对Alice ...也转播它（回到服务器现在有它，然后碰撞和停止），爱丽丝也看到它是一个保存请求的ACK，现在知道她得到了2个复制。

最后

我们完成了。

这是一种场景，有限的对等点，明星配置（连接到服务器中间人的对等点）以及没有网络打嗝的情况。

幸运的是，这种算法适用于每种配置都很好，但对于所有设置来说，它并不总是最智能或最精明的。但是，再次感谢，它可以很好地调整，以获得更好的性能....但作为基本情况，它可以缓解消息泛滥和无限循环。

我想是这样！请这样做，因为我应该在文档中找到它。

现在，处理网络打嗝。我不会再重复一遍，我只是要解释规则。

创建数据并希望它复制的对等体是SOLEY负责重试，如果它没有收到它想要的ACK。

没有其他同行负责重试消息。

所以对于试图复制数据的同伴来说，尽可能多地保留数据直到他们至少得到一个ACK是非常非常重要的。这意味着同行（不管它像浏览器那么“弱”）确实至少在localStorage（只有5MB）这样的东西中存储未确认的数据是非常重要的。

因此它有责任优先考虑持久性，直到它得到ACK，并且即使它确实得到了ACK，它仍应该可能存储数据的副本（以防其他对等失败/损坏）。

但是说发起方有重试责任，大大简化了事情。

所以如果它没有得到一个答案...它可以重试。在这种情况下，重试运行通过相同的算法。

现在，网络呃逆。

*对不起，同事崩溃/重新启动

^重试包含网络打嗝。

发生这种情况时，如果我们有新的同伴加入会发生什么？

如果对方崩溃并重新启动，会发生什么情况？

最糟糕的情况是服务器崩溃

而其固定大小的msg ID列表仅在内存中

所以当它恢复在线时，它已经忘记了哪些消息已经在广播风暴中

所以两个快速情况下：

如果服务器在整个过程完成并重新联机后崩溃。与whoopty-doo相比，转播信息已经发送给所有同行并得到缓解。

它已经失去了历史并不重要，因为这个信息不会再出现。

但是，如果服务器在连接的同级仍在运行时崩溃

所连接的对等体然后“回显”它（服务器）刚刚发送给他们的msg ID ....

服务器继续前进并重新播送它（同时将其添加到其可见列表中）

但没关系

因为它所连接的所有同伴都已经看到了，所以他们暂停了。

除非有两位邻居同行在这种情况发生时崩溃......那么其中一位可能不知道它已经看到并重播。但这个故事的寓意在于，重播风暴实际上是相邻的。

这是一件好事。

例如（新的例子）

如果我有一个与另外3个人相连的同伴

而另外3个人与另外2个人连接。

呃，呃。

我该如何解释这一点

想象一波

就像一滴水滴入水中一样

它创造了一个向外飘动的波浪

浪潮不会逆转回来

因为它干扰了自身（这也是量子力学中光子在粒子水平上发生的情况）

波浪中心的干扰回波...减轻了波在已经看到的地方扩散

但没有看到它......它一直在荡漾

所以回到这个例子...

服务器位于其他三个同行的中心（Alice，Bob，Carl）

服务器将消息转播给Alice Bob Carl

它在爱丽丝鲍伯卡尔回来之前崩溃并重新启动

所以它认为它还没有看到消息

所以它重新播放给Alice Bob和Carl

但是由于所有服务器的邻居节点都已经看到这个消息，所以他们不会重新发射它，所以它会被终止，服务器崩溃并重新启动并没有什么关系，这是优先级碰撞的重要性。 msg ID ...表示消息风暴的活力。

所以假设爱丽丝连接到戴夫和弗雷德

鲍勃被连接到埃文和加布

Carl与Hugh＆Ian有联系。

第一次服务器转交给Alice＆Bob＆Carl。服务器崩溃并在A＆B＆C回显之前重新启动....

A＆B＆C的回音也是A＆B＆C对邻居同行的重播。接收消息并回显。

但是2度分离的回波不返回到服务器，导致A＆B＆C缓解它（因为他们已经将它交付给D＆E＆F＆G＆H＆I以来就已经看到了它）

这也很好

因为即使服务器（和我在这里使用的“服务器”只是一个名字，它没有特别的含义....假设它们是所有服务器）

因为即使服务器崩溃和Gabe崩溃

如果他们重新启动并忘记了他们已经看到了身份证

他们会重播

但他们的邻居会减轻

所以服务器被遗忘和重播的消息将不会再次加贝。而Gabe被遗忘并重新播放的人不会回到服务器。

这很棒。因为它从字面上看起来像一个浪潮。

Ahmed Fasih @fasiha 10:57

:clap: 看起来很复杂，但它实际上是最简单的事情

Mark Nadal @amark 10:57

并且该功能的发生是因为msg ID优先级缓冲使得msg ID的活泼广播风暴不断被缓解......直到它真正消失，并且在固定大小的msg ID列表中变得如此“旧”清除。因为没有广播风暴，所以清除是安全的。

DONE

yupe，而且最聪明的和更聪明的行为涌现！

