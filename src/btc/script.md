# 第七章 高级交易和脚本

### 多重签名

多重签名脚本设置了一个条件，其中N个公钥被记录在脚本中，并且至少有M个必须提供签名来解锁资金。这也称为M-N方案，其中N是密钥的总数，M是验证所需的签名的数量。

### P2SH

+ 虽然多重签名十分强大，但其使用起来还是多有不便。  
+ 此外，由于脚本可能包含特别长的公钥，最终的交易脚本可能是最初交易脚本长度的5倍之多。  
+ P2SH正是为了解决这一实际难题而被引入的，它旨在使复杂脚本的运用能与直接向比特币地址支付一样简单。  
+ 当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。  
+ 在P2SH交易中，锁定脚本由哈希运算后的20字节的散列值取代，被称为赎回脚本。

### 数据记录输出

在0.9版的比特币核心客户端上，通过采用Return操作符最终实现了妥协。Return允许开发者在交易输出上增加80字节的非交易数据。然后，与伪交易型的UTXO不同，Return创造了一种明确的可复查的非交易型输出，此类数据无需存储于UTXO集。  

请记住 RETURN 不涉及可用于支付的解锁脚本的特点， RETURN 不能使用其输出中所锁定的资金，因此它也就没有必要记录在蕴含潜在成本的UTXO集中，所以 RETURN 实际是没有成本的。  

RETURN 常为一个金额为0的比特币输出， 因为任何与该输出相对应的比特币都会永久消失。假如一笔 RETURN 被作为一笔交易的输入，脚本验证引擎将会阻止验证脚本的执行，将标记交易为无效。  

> 最初提出了RETURN，限制为80字节，但是当功能被释放时，限制被减少到40字节。 2015年2月，在Bitcoin Core的0.10版本中，限制提高到80字节。 节点可以选择不中继或重新启动RETURN，或者只能中继和挖掘包含少于80字节数据的RETURN。

### 时间锁

nnSequence 字段的设计初心是想让交易能在在内存中修改，可惜后面从未运用过，使用 nSequence 这个字段时，如果输入的交易的序列值小于2^32（0xFFFFFFFF），就表示尚未“确定”的交易。这样的交易将在内存池中保存，直到被另一个交易消耗相同输入并具有较大nSequence值的代替。  

时间锁是只允许在一段时间后才允许指出的交易。比特币从一开始就有一个交易级的时间锁定功能。它由交易中的nLocktime字段实现。  

交易可以包括时间锁定输入（nSequence <2^31）和没有相对时间锁定（nsequence> = 2^31）的输入。 nSequence值以块或秒为单位指定，但与nLocktime中使用的格式略有不同。类型标志用于区分计数块和计数时间（以秒为单位）的值。  

**中位时间过去**  
比特币是一个分散的网络，这意味着每个参与者都有自己的时间观。网络上的事件不会随时随地发生。区块头中设置的时间戳由矿工设定。共识规则允许一定的误差来解决分散节点之间时钟精度的问题。为了杜绝矿工说谎，加强时间安全性，在相对时间锁的基础上又新增了一个BIP。**通过取最后11个块的时间戳并计算其中位数作为“中位时间过去”的值。**这是BIP-113，它定义了一个称为“中位时间过去 /（Median-Time-Past）”的新的共识测量机制。  

**针对费用狙击的时间锁定**  
矿工可以通过重写区块，来重新获取交易费。在 Bitcoin Core / 钱包中，使用 nLocktime 限制着一行为的发生。

**具有流量控制的脚本**  
比特币脚本的一个更强大的功能是流量控制，也称为条件条款。您可能熟悉使用构造IF ... THEN ... ELSE的各种编程语言中的流控制。比特币条件条款看起来有点不同，但是基本上是相同的结构。  

**带有 VERIFY 操作码的条件子句**  
比特币脚本中的另一种条件是任何以VERIFY结尾的操作码。 VERIFY后缀表示如果评估的条件不为TRUE，脚本的执行将立即终止，并且该交易被视为无效。  

