# 第六章 交易

## 简介

比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿（比特币区块链）。

**解码后的交易**
```
{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid":"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
 ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}
```
在比特币里，没有具体的货币，没有发送者，没有接收者，没有余额，没有账户，没有地址。

## 交易的输入和输出

用户的比特币“余额”是指用户钱包中可用的UTXO总和，而他们可能分散在数百个交易和区块中。一个UTXO可以是1“聪”（satoshi）的任意倍数（整数倍）。比特币可以被分割成八位小数的"聪"。UTXO是面值为“聪”的离散（不连续）且不可分割的价值单元，一个 UTXO 只能在一次交易中作为一个整体被消耗。  
一笔交易会消耗先前的已被记录（存在）的UTXO，并创建新的UTXO以备未来的交易消耗。通过这种方式，一定数量的比特币价值在不同所有者之间转移，并在交易链中消耗和创建UTXO。一笔比特币交易通过使用所有者的签名来解锁UTXO，并通过使用新的所有者的比特币地址来锁定并创建UTXO。

## 交易输出

每一笔交易都会创造输出，几乎所有的输出都能创造一定数量的可用于支付的比特币，也就是 UTXO。UTXO 在 UTXO 集中被每一个全节点比特币客户端追踪。新的交易从 UTXO 集中消耗一个或多个输出。  

交易输出包含两部分:
+ 一定量的比特币，面值为 "聪"，是最小的比特币单位。
+ 确定话费输出所需条件的加密难题。

```
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY
OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
  }
]
```
> 如您所见，交易包含两个输出。 每个输出都由一个值和一个加密难题来定义。 在 Bitcoin Core 显示的编码中，该值显示以 bitcoin 为单位，但在交易本身中，它被记录为以 satoshis 为单位的整数。 每个输出的第二部分是设定支出条件的加密难题。 

## 交易序列化 - 输出

当交易通过网络传输或在应用程序之间交换时，它们被序列化。 序列化是将内部的数据结构表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。

| Size                    | Field               | Description                                                  |
|-------------------------|---------------------|--------------------------------------------------------------|
| 8 bytes (little-endian) | Amount              | Bitcoin value in satoshis (10^-8 bitcoin)                    |
| 1-9 bytes (VarInt)      | Locking-Script Size | Locking-Script length in bytes, to follow                    |
| Variable                | Lockingn-Script     | A script defininng the conditions needed to spend the output |

> 大多数比特币函数库和架构不会在内部将交易存储为字节流，因为每次需要访问单个字段时，都需要复杂的解析。为了方便和可读性，比特币函数库将交易内部存储在数据结构（通常是面向对象的结构）中。

## 交易序列化 - 交易输入

当交易被序列化以在网络上传输时，它们的输入被编码成字节流。

| Size      | Field                 | Description                                                       |
|-----------|-----------------------|-------------------------------------------------------------------|
| 32 bytes  | Transaction Hash      | Pointer to the transaction containing the UTXO to be spent        |
| 4 bytes   | Output index          | The index nnumber of the UTXO to be spent; first one is 0         |
| 1-9 bytes | Unlocking-Script Size | Unlocking-Script length in bytes, to follow                       |
| Variable  | Unlocking-Script      | A script that fullfills the conditions of the UTXO locking script |
| 4 bytes   | Sequence Number       | Used for locktime or disabled (0xFFFFFFFF)                        |

## 交易费

交易费是基于交易的千字节规模来计算的，而不是比特币交易的价值。  
总的来说，交易费是根据比特币网络中的市场力量确定的。矿工会依据许多不同的标准对交易进行优先级排序，包括费用，他们甚至可能在某些特定情况下免费处理交易。  
但大多数情况下，交易费影响处理优先级，这意味着有足够费用的交易会更可能被打包进下一个挖出的区块中；反之交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，而且没有交易费的交易最终也可能会被处理，但是，交易费将提高处理优先级。  

随着时间的推移，交易费的计算方式以及在交易处理优先级上的影响已经产生了变化。起初，交易费是固定的，是网络中的一个固定常数。渐渐地，随着网络容量和交易量的不断变化，并可能受到来自市场力量的影响，收费结构开始放松。自从至少2016年初以来，比特币网络容量的限制已经造成交易之间的竞争，从而导致更高的费用，免费交易彻底成为过去式。零费用或非常低费用的交易鲜少被处理，有时甚至不会在网络上传播。  

## 把交易加到交易中

举例来说，如果你消耗了一个20比特币的UTXO来完成1比特币的付款，你必须包含一笔19比特币的找零回到你的钱包。否则，那剩下的19比特币会被当作交易费，并将由挖出你交易的矿工收走。尽管你会得到高优先级的处理，并且让一个矿工喜出望外，但这很可能不是你想要的。
> 如果你忘记了在手动构造的交易中增加找零的输出，系统会把找零当作交易费来处理。“不用找了！”也许不是你的真实意愿。

**比特币脚本**  
比特币交易脚本语言，称为脚本，是一种类似Forth的逆波兰表达式的基于堆栈的执行语言。
> 比特币脚本语言包含许多操作码，但都故意限定为一种重要的模式——除了有条件的流控制以外，没有循环或复杂流控制能力。这样就保证了脚本语言的图灵非完备性，这意味着脚本有限的复杂性和可预见的执行次数。

一个脚本能在任何系统上以相同的方式执行。如果您的系统验证了一个脚本，可以确信的是每一个比特币网络中的其他系统也将验证这个脚本，这意味着一个有效的交易对每个人而言都是有效的，而且每一个人都知道这一点。  

**解锁脚本**  
解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，它将允许输出被消费。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包（通过用户的私钥）生成的数字签名。

**脚本堆栈**  

![stack](/assets/stack.png)  
尽管绝大多数解锁脚本都指向一个公钥哈希值（本质上就是比特币地址），因此如果想要使用资金则需验证所有权，但脚本本身并不需要如此复杂。任何解锁和锁定脚本的组合如果结果为真（TRUE），则为有效。

**P2PKH**  
比特币网络处理的大多数交易花费的都是由“付款至公钥哈希”（或P2PKH）脚本锁定的输出，这些输出都含有一个锁定脚本，将输入锁定为一个公钥哈希值，即我们常说的比特币地址。由P2PKH脚本锁定的输出可以通过提供一个公钥和由相应私钥创建的数字签名来解锁（使用）。

**数字签名**  
数字签名在比特币中有三种用途（请参阅下面的侧栏）。
+ 第一，签名证明私钥的所有者，即资金所有者，已经授权支出这些资金。
+ 第二，授权证明是不可否认的（不可否认性）。
+ 第三，签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改。

### 数字签名如何工作
数字签名是一种由两部分组成的数学方案：第一部分是使用私钥（签名密钥）从消息（交易）创建签名的算法； 第二部分是允许任何人验证签名的算法，给定消息和公钥。

**创建数字签名**  
在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值（参见签名哈希类型（SIGHASH））。签名密钥是用户的私钥，结果是签名：
```
((Sig = F{sig}(F{hash}(m), dA)))
```
+ dA 是签名私钥
+ m 是交易（或其部分）
+ F~hash~ 是散列函数
+ F~sig~ 是签名算法
+ Sig 是结果签名

> 现在已经计算了两个值R和S，它们就序列化为字节流，使用一种称为“分辨编码规则”（Distinguished Encoding Rules）或 DER的国际标准编码方案。

**签名序列化**  

```
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301
```

+ 0x30表示DER序列的开始
+ 0x45 - 序列的长度（69字节）
+ 0x02 - 一个整数值
+ 0x21 - 整数的长度（33字节）
+ R-00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb
+ 0x02 - 接下来是一个整数
+ 0x20 - 整数的长度（32字节）
+ S-4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813
+ 后缀（0x01）指示使用的哈希的类型（SIGHASH_ALL）

**验证签名**  
签名验证算法采用消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值），如果签名对该消息和公钥有效，则返回 TRUE 值。  

**签名哈希类型（SIGHASH）**   
包含多个输入的交易可以拥有具有不同SIGHASH标志的签名，这些标志在每个输入中承诺交易的不同部分。还要注意，比特币交易可能包含来自不同“所有者”的输入，他们在部分构建（和无效）的交易中可能仅签署一个输入，继而与他人协作收集所有必要的签名后再使交易生效。许多SIGHSASH标志类型，只有在你考虑到由许多参与者在比特币网络之外共同协作去更新仅部分签署了的交易，才具有意义。  




<style>img{padding: 5rem; 10rem;}</style>
